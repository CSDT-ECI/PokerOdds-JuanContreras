# Code Smells #
- PokerOdds.Mvc.Web.Controllers.TexasHoldemController 

### Problema 1 (Magic Numbers)
Se está utilizando el número 10 directamente en el código. Sería mejor declarar esta constante como una variable o propiedad con un nombre descriptivo
~~~csharp

if (stopWatch.Elapsed > TimeSpan.FromSeconds(10))
...
//Tecnica de refactor para el codigo : Replace Magic Literal/Numbers 
    int stopWatchSeconds = 10;
    int cardsNumber = 7;
    int twoCards = 2;
    int fiveCards = 5;
    long winner = 1.0;
    long HalfCreditsTies = 0.5;
    long Percentage = 100.0;
//Ya corregido en Codigo
~~~
### Problema 2 (Manejo de Excepciones)
No hay manejo explícito de excepciones en el código. Sería útil agregar bloques try-catch para manejar posibles excepciones y proporcionar información detallada en caso de errores.
~~~csharp


//Tecnica de refactor para el codigo : se Agregan bloques try catch para tener control de excepciones 
 [OutputCache]
 public TexasHoldemOdds Get(string pocket, string board)
 {
     try
     {
        ...
        }
    catch (Exception ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
        return null;
    }
}
//Ya corregido en Codigo
~~~

### Problema 3 (Long Method)
El método Get es bastante largo y realiza múltiples funciones. Sería beneficioso dividirlo en métodos más pequeños y específicos para mejorar la legibilidad y mantener la coherencia con el principio de responsabilidad única
~~~csharp

//Refactor :
//he encapsulado la lógica  en tres métodos (IterateOpponentHands, IterateBoards, y EvaluateHands) dividiendo el codigo en metodos mas pequeños
 public TexasHoldemOdds Get(string pocket, string board)
 {
    ...
 }

 private void IterateOpponentHands(ulong partialBoard, ulong playerMask, double[] playerWins, double[] opponentWins, ref long count, ref Stopwatch stopWatch)
 {
    ...
 }

 private void IterateBoards(ulong partialBoard, ulong playerMask, double[] playerWins, double[] opponentWins, ref long count, ref Stopwatch stopWatch, ulong opponentMask)
 {
    ...
 }

 private void EvaluateHands(ulong playerMask, ulong opponentMask, double[] playerWins, double[] opponentWins, ref long count, ref Stopwatch stopWatch, ulong boardMask)
 {
    ...
 }

 private void CreateOutcomes(double[] playerWins, long count, List<PokerOutcome> outcomes)
 {
   ...
 }
//ya corregido en codigo
~~~
# Clean Code + XP Practices #
Analizar las características de Clean Code vistas en clase e indicar cuales de estas se están cumpliendo y argumentar, de las que no se están cumpliendo indicar algunas recomendaciones 
## Clean Code ##
### Código enfocado
-PokerOdds.Mvc.Web.Controllers.TexasHoldemController 
Como se menciona en el apartado de Code Smells, el método Get es bastante largo y realiza múltiples funciones. Se dividió en métodos más pequeños y específicos para mejorar la legibilidad y mantener la coherencia con el principio de responsabilidad única
### Regla del Boy Scout
Revisando los commits del autor del repo, se evidencia un constante refactor sumado a la solución de los code Smells identificados por mi parte en la actividad anterior, por lo tanto, cumple estas características.
![Descripción de la imagen](/images/BoyScout.png)
### Entendible
Nuestro código cumple con el principio YAGNI pero no con el principio KIS(S), esto se debe a que no toda la lógica se encuentra fácil de comprender y mantiene métodos grandes que se podría dividir en métodos más pequeños y claros
### Escalable
### Duplicidad
En el Código no existen métodos que repitan funciones de otras, entonces cumple con esta característica 
### Abstracción
-PokerOdds.Mvc.Web.Controllers.TexasHoldemController
-PokerOdds.HandEvaluator.HandAnalysis.cs
Son solo un par de ejemplos donde no se cumple la Abstracción esto se debe a que las clases además de ser extensas poseen métodos que para solucionar esto,  podrían dividirse en métodos más sencillos para facilitar la lectura del código. 
### Testeable
-PokerOdds.Mvc.Web.Tests/Controllers/ValuesControllerTest.cs
A pesar de contar con pruebas estas carecen de extensión, por lo que no se prueban todas las funcionalidades de la solución, como recomendación se deberían extender las pruebas ya que en un entorno real probablemente por el coverage  un paso a producción de este código no sería posible.
### Principio menor asombro
No lo cumple, por ejemplo si revisamos el archivo PokerOdds.HandEvaluator.HandAnalysis.cs dada la extensión del método si  realiza lo que su nombre indica pero no se limita solo a esto , la recomendación seria nuevamente dividir los métodos en varios más pequeños y descriptivos.
## Principios SOLID ##
### Principios que se cumplen:
SRP (Principio de responsabilidad única): Las clases en general tienen una única responsabilidad bien definida.
OCP (Principio abierto-cerrado): Las clases están abiertas para la extensión pero cerradas para la modificación.
LSP (Principio de sustitución de Liskov): Las clases derivadas pueden sustituir a sus clases base sin cambiar el comportamiento del programa.
DIP (Principio de inversión de dependencias): Las clases dependen de abstracciones, no de implementaciones concretas.
###Principios que no se cumplen:
ISP (Principio de interfaz de segregación): Algunas interfaces podrían dividirse en interfaces más pequeñas y específicas.
### Ejemplos de cómo se cumplen los principios SOLID:
La clase HandEvaluator tiene la responsabilidad de evaluar la mano de un jugador.
La clase PocketHands es abstracta y no se puede instanciar directamente.
La clase Straight hereda de la clase Hand y puede sustituirla en cualquier contexto.
La clase IHandEvaluator define una interfaz que puede ser implementada por diferentes clases.
### Ejemplos de cómo no se cumplen los principios SOLID:
La interfaz IHandEvaluator contiene métodos que no son necesarios para todas las clases que la implementan.
La clase HandEvaluator crea instancias de clases concretas, como Straight y Flush.
### Recomendaciones:
Dividir la interfaz IHandEvaluator en interfaces más pequeñas y específicas.
Usar la inyección de dependencias para crear instancias de clases concretas
## XP Practices ##
### Pruebas del cliente
Los clientes participan en las pruebas del software para asegurar que cumple con sus necesidades, si el robot que ayuda a calcular probabilidades no sirve en un entorno real, toca entrar a revisar como ajustarlo para que sea útil.
### Diseño simple
Se busca crear un diseño simple y fácil de entender, lo que facilita el mantenimiento del software, así como está actualmente puede ser complejo comprender partes del código y dificultar su mantenimiento.
### Refactorización
Se mejora el código de forma continua para hacerlo más legible, mantenible y extensible, se puede realizar para aplicar el diseño simple.
### Retroalimentación
Se fomenta la retroalimentación entre los miembros del equipo y con los usuarios.

